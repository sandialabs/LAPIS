"#include <Kokkos_Core.hpp>\n"
"#include <type_traits>\n"
"#include <cstdint>\n"
"#include <unistd.h>\n"
"#include <iostream>\n"
"\n"
"// If building a CPP driver, we can use the original StridedMemRefType class from MLIR,\n"
"// so do not redefine it here.\n"
"#ifndef PYTACO_CPP_DRIVER\n"
"template <typename T, int N>\n"
"struct StridedMemRefType {\n"
"  T *basePtr;\n"
"  T *data;\n"
"  int64_t offset;\n"
"  int64_t sizes[N];\n"
"  int64_t strides[N];\n"
"};\n"
"#endif\n"
"\n"
"// If building a CPP driver, need to provide a version of\n"
"// _mlir_ciface_newSparseTensor() that takes underlying integer types, not enum types like DimLevelType.\n"
"// The MLIR-Kokkos generated code doesn\'t know about the enum types at all.\n"
"#ifdef PYTACO_CPP_DRIVER\n"
"int8_t* _mlir_ciface_newSparseTensor(\n"
"  StridedMemRefType<index_type, 1> *dimSizesRef,\n"
"  StridedMemRefType<index_type, 1> *lvlSizesRef,\n"
"  StridedMemRefType<int8_t, 1> *lvlTypesRef,\n"
"  StridedMemRefType<index_type, 1> *lvl2dimRef,\n"
"  StridedMemRefType<index_type, 1> *dim2lvlRef, int ptrTp,\n"
"  int indTp, int valTp, int action, int8_t* ptr) {\n"
"    return (int8_t*) _mlir_ciface_newSparseTensor(dimSizesRef, lvlSizesRef,\n"
"      reinterpret_cast<StridedMemRefType<DimLevelType, 1>*>(lvlTypesRef),\n"
"      lvl2dimRef, dim2lvlRef, (OverheadType) ptrTp, (OverheadType) indTp,\n"
"      (PrimaryType) valTp, (Action) action, ptr);\n"
"  }\n"
"#endif\n"
"\n"
"namespace LAPIS\n"
"{\n"
"  using TeamPolicy = Kokkos::TeamPolicy<>;\n"
"  using TeamMember = typename TeamPolicy::member_type;\n"
"\n"
"  template<typename V>\n"
"    StridedMemRefType<typename V::value_type, V::rank> viewToStridedMemref(const V& v)\n"
"    {\n"
"      StridedMemRefType<typename V::value_type, V::rank> smr;\n"
"      smr.basePtr = v.data();\n"
"      smr.data = v.data();\n"
"      smr.offset = 0;\n"
"      for(int i = 0; i < int(V::rank); i++)\n"
"      {\n"
"        smr.sizes[i] = v.extent(i);\n"
"        smr.strides[i] = v.stride(i);\n"
"      }\n"
"      return smr;\n"
"    }\n"
"\n"
"  template<typename V>\n"
"    V stridedMemrefToView(const StridedMemRefType<typename V::value_type, V::rank>& smr)\n"
"    {\n"
"      using Layout = typename V::array_layout;\n"
"      static_assert(std::is_same_v<typename V::memory_space, Kokkos::HostSpace> ||\n"
"          std::is_same_v<typename V::memory_space, Kokkos::AnonymousSpace>,\n"
"          \"Can only convert a StridedMemRefType to a Kokkos::View in HostSpace.\");\n"
"      if constexpr(std::is_same_v<Layout, Kokkos::LayoutStride>)\n"
"      {\n"
"        size_t extents[8] = {0};\n"
"        size_t strides[8] = {0};\n"
"        for(int i = 0; i < V::rank; i++) {\n"
"          extents[i] = smr.sizes[i];\n"
"          strides[i] = smr.strides[i];\n"
"        }\n"
"        Layout layout(\n"
"            extents[0], strides[0],\n"
"            extents[1], strides[1],\n"
"            extents[2], strides[2],\n"
"            extents[3], strides[3],\n"
"            extents[4], strides[4],\n"
"            extents[5], strides[5],\n"
"            extents[6], strides[6],\n"
"            extents[7], strides[7]);\n"
"        return V(&smr.data[smr.offset], layout);\n"
"      }\n"
"      size_t extents[8] = {0};\n"
"      for(int i = 0; i < V::rank; i++)\n"
"        extents[i] = smr.sizes[i];\n"
"      Layout layout(\n"
"          extents[0], extents[1], extents[2], extents[3],\n"
"          extents[4], extents[5], extents[6], extents[7]);\n"
"      if constexpr(std::is_same_v<Layout, Kokkos::LayoutLeft>)\n"
"      {\n"
"        int64_t expectedStride = 1;\n"
"        for(int i = 0; i < int(V::rank); i++)\n"
"        {\n"
"          if(expectedStride != smr.strides[i])\n"
"            Kokkos::abort(\"Cannot convert non-contiguous StridedMemRefType to LayoutLeft Kokkos::View\");\n"
"          expectedStride *= smr.sizes[i];\n"
"        }\n"
"      }\n"
"      else if constexpr(std::is_same_v<Layout, Kokkos::LayoutRight>)\n"
"      {\n"
"        int64_t expectedStride = 1;\n"
"        for(int i = int(V::rank) - 1; i >= 0; i--)\n"
"        {\n"
"          if(expectedStride != smr.strides[i])\n"
"            Kokkos::abort(\"Cannot convert non-contiguous StridedMemRefType to LayoutRight Kokkos::View\");\n"
"          expectedStride *= smr.sizes[i];\n"
"        }\n"
"      }\n"
"      return V(&smr.data[smr.offset], layout);\n"
"    }\n"
"\n"
"  struct DualViewBase\n"
"  {\n"
"    virtual ~DualViewBase() {}\n"
"    virtual void syncHost() = 0;\n"
"    virtual void syncDevice() = 0;\n"
"    bool modified_host = false;\n"
"    bool modified_device = false;\n"
"  };\n"
"\n"
"  template<typename DataType, typename Layout>\n"
"    struct DualView : public DualViewBase\n"
"  {\n"
"    using HostView = Kokkos::View<DataType, Layout, Kokkos::DefaultHostExecutionSpace>;\n"
"    using DeviceView = Kokkos::View<DataType, Layout, Kokkos::DefaultExecutionSpace>;\n"
"\n"
"    static constexpr bool deviceAccessesHost = Kokkos::SpaceAccessibility<Kokkos::DefaultHostExecutionSpace, typename DeviceView::memory_space>::accessible;\n"
"    static constexpr bool hostAccessesDevice = Kokkos::SpaceAccessibility<Kokkos::DefaultHostExecutionSpace, typename DeviceView::memory_space>::accessible;\n"
"\n"
"    // Default constructor makes empty views and self as parent.\n"
"    DualView() : device_view(), host_view(), parent(this) {}\n"
"\n"
"    // Constructor for allocating a new view.\n"
"    // Does not actually allocate anything yet; instead \n"
"    DualView(\n"
"        const std::string& label,\n"
"        size_t ex0 = KOKKOS_INVALID_INDEX, size_t ex1 = KOKKOS_INVALID_INDEX, size_t ex2 = KOKKOS_INVALID_INDEX, size_t ex3 = KOKKOS_INVALID_INDEX,\n"
"        size_t ex4 = KOKKOS_INVALID_INDEX, size_t ex5 = KOKKOS_INVALID_INDEX, size_t ex6 = KOKKOS_INVALID_INDEX, size_t ex7 = KOKKOS_INVALID_INDEX)\n"
"    {\n"
"      if constexpr(hostAccessesDevice) {\n"
"        device_view = DeviceView(Kokkos::view_alloc(Kokkos::WithoutInitializing, label + \"_dev\"), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"        host_view = HostView(device_view.data(), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"      }\n"
"      else if constexpr(deviceAccessesHost) {\n"
"        // Otherwise, host_view must be a separate allocation.\n"
"        host_view = HostView(Kokkos::view_alloc(Kokkos::WithoutInitializing, label + \"_host\"), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"        device_view = DeviceView(host_view.data(), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"      }\n"
"      else {\n"
"        device_view = DeviceView(Kokkos::view_alloc(Kokkos::WithoutInitializing, label + \"_dev\"), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"        host_view = HostView(Kokkos::view_alloc(Kokkos::WithoutInitializing, label + \"_host\"), ex0, ex1, ex2, ex3, ex4, ex5, ex6, ex7);\n"
"      }\n"
"      parent = this;\n"
"    }\n"
"\n"
"    // Constructor which is given explicit device and host views, and a parent.\n"
"    // This can be used for subviewing/casting operations.\n"
"    // Note: d,h should view the same memory as parent, but they can\n"
"    // have a different data type and layout.\n"
"    DualView(DeviceView d, HostView h, DualViewBase* parent_)\n"
"      : device_view(d), host_view(h), parent(parent_)\n"
"    {}\n"
"\n"
"    // Constructor for a host view from an external source (e.g. python)\n"
"    DualView(HostView h)\n"
"    {\n"
"      modified_host = true;\n"
"      if constexpr(deviceAccessesHost) {\n"
"        device_view = DeviceView(h.data(), h.layout());\n"
"      }\n"
"      else {\n"
"        device_view = DeviceView(Kokkos::view_alloc(Kokkos::WithoutInitializing, h.label() + \"_dev\"), h.layout());\n"
"      }\n"
"      host_view = h;\n"
"      parent = this;\n"
"    }\n"
"\n"
"    // Copy-assignment equivalent to the above constructor.\n"
"    // Shallow copying a temporary DualView to a persistent one leaves the\n"
"    // persistent one in an invalid state, since its parent pointer still points to the temporary.\n"
"    //\n"
"    // Shallow-copy from one persistent DualView to another persistent or temporary is OK, as long\n"
"    // as the lifetime of original covers the lifetime of the copy.\n"
"    DualView& operator=(const HostView& h)\n"
"    {\n"
"      modified_host = true;\n"
"      if constexpr(deviceAccessesHost) {\n"
"        device_view = DeviceView(h.data(), h.layout());\n"
"      }\n"
"      else {\n"
"        device_view = DeviceView(Kokkos::view_alloc(Kokkos::WithoutInitializing, h.label() + \"_dev\"), h.layout());\n"
"      }\n"
"      host_view = h;\n"
"      parent = this;\n"
"      return *this;\n"
"    }\n"
"\n"
"    void modifyHost()\n"
"    {\n"
"      parent->modified_host = true;\n"
"    }\n"
"\n"
"    void modifyDevice()\n"
"    {\n"
"      parent->modified_device = true;\n"
"    }\n"
"\n"
"    void syncHost() override\n"
"    {\n"
"      if (device_view.data() == host_view.data()) {\n"
"        if(parent->modified_device) {\n"
"          parent->modified_device = false;\n"
"          Kokkos::fence();\n"
"        }\n"
"      }\n"
"      else if (parent->modified_device) {\n"
"        if(parent == this) {\n"
"          Kokkos::deep_copy(host_view, device_view);\n"
"          modified_device = false;\n"
"        }\n"
"        else {\n"
"          parent->syncHost();\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    void syncDevice() override\n"
"    {\n"
"      // If host and device views are the same, do not sync or fence\n"
"      // because all host execution spaces are synchronous.\n"
"      // Any changes on the host side are immediately visible on the device side.\n"
"      if (device_view.data() != host_view.data()) {\n"
"        if(parent == this) {\n"
"          if(modified_host) {\n"
"            Kokkos::deep_copy(device_view, host_view);\n"
"            modified_host = false;\n"
"          }\n"
"        }\n"
"        else {\n"
"          parent->syncDevice();\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    void deallocate() {\n"
"      device_view = DeviceView();\n"
"      host_view = HostView();\n"
"    }\n"
"\n"
"    DeviceView device_view;\n"
"    HostView host_view;\n"
"    DualViewBase* parent;\n"
"  };\n"
"} // namespace LAPIS\n"
"\n"
""
