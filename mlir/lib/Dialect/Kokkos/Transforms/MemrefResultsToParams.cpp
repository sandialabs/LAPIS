//===- MemrefResultsToParams.cpp -
// Patterns to move memref return values to parameters
//--------------------===//

#include "lapis/Dialect/Kokkos/IR/KokkosDialect.h"
#include "lapis/Dialect/Kokkos/Transforms/Passes.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/MemRef/IR/MemRef.h"
#include "mlir/IR/IRMapping.h"
#include "mlir/IR/Matchers.h"
#include "mlir/Transforms/GreedyPatternRewriteDriver.h"

namespace mlir {
#define GEN_PASS_DEF_MEMREFRESULTSTOPARAMS
#include "lapis/Dialect/Kokkos/Transforms/Passes.h.inc"
}

using namespace mlir;

struct MemrefResultsToParamsPass
    : public impl::MemrefResultsToParamsBase<MemrefResultsToParamsPass> {

  MemrefResultsToParamsPass() = default;
  MemrefResultsToParamsPass(const MemrefResultsToParamsPass& pass) = default;

  void rewriteFunction(IRRewriter& rewriter, MLIRContext* ctx, func::FuncOp oldFunc) {
    // Can't run on extern functions
    if(oldFunc.isExternal())
      return;
    // Get return statement (there should be exactly one)
    Region& oldBody = oldFunc.getBody();
    int numReturns = std::distance(oldBody.op_begin<func::ReturnOp>(), oldBody.op_end<func::ReturnOp>());
    if(numReturns != 1) {
      oldFunc->emitError("Function does not have exactly one return statement");
    }
    if(!oldBody.hasOneBlock()) {
      oldFunc->emitError("Function's body region does not have exactly one block");
    }
    func::ReturnOp ret = *(oldBody.op_begin<func::ReturnOp>());
    // For each returned memref whose parent is allocated in the function,
    // this pass inserts a new parameter (at beginning) for that parent.
    // For each returned memref that is directly the result of memref.alloc,
    // remove that return value (since it's identical to the corresponding new parameter)
    //
    // If a returned memref's parent is the result of some other op like scf.if or func.call,
    // then just error out (rewriting in this case would be more complicated)
    SmallVector<int> returnsToMakeParams;
    SmallVector<int> returnsToDelete;
    // List of allocs to delete, and the corresponding new parameter to replace its result with
    DenseMap<memref::AllocOp, int> allocsToDelete;
    {
      int i = 0;
      for(auto rv : ret->getOperands()) {
        if(isa<MemRefType>(rv.getType())) {
          Value rvParent = kokkos::getParentMemref(rv);
          if(auto alloc = dyn_cast<memref::AllocOp>(rvParent.getDefiningOp())) {
            // OK, rv's memory allocated inside function.
            allocsToDelete[alloc] = returnsToMakeParams.size();
            returnsToMakeParams.push_back(i);
            if(rv == rvParent) {
              // Also delete the return value.
              returnsToDelete.push_back(i);
            }
          }
          else {
            // rvParent generated by some other op that we don't know how to handle
            ret->emitError("Memref-typed return value was generated by op other than alloc or shallow copy/cast");
          }
        }
        i++;
      }
    }
    if(!returnsToMakeParams.size() && !returnsToDelete.size()) {
      // Early exit because no changes to make
      return;
    }
    // Create rewritten version of the function
    rewriter.setInsertionPoint(oldFunc);
    
    auto oldParamTypes = oldFunc.getArgumentTypes();
    auto oldRetTypes = oldFunc.getResultTypes();
    SmallVector<Type> newParamTypes;
    SmallVector<Type> newRetTypes;

    // insert the new params at the front
    for(int retToParam : returnsToMakeParams) {
      // Will make return value's parent a parameter
      Value retParent = kokkos::getParentMemref(ret->getOperands()[retToParam]);
      newParamTypes.push_back(retParent.getType());
    }
    // then add all the original params
    for(Type pt : oldParamTypes)
      newParamTypes.push_back(pt);
    // For returns, just delete the marked ones
    newRetTypes.append(oldRetTypes.begin(), oldRetTypes.end());
    for(int i = returnsToDelete.size() - 1; i >= 0; i--) {
      newRetTypes.erase(newRetTypes.begin() + returnsToDelete[i]);
    }

    func::FuncOp newFunc = rewriter.create<func::FuncOp>(oldFunc.getLoc(), oldFunc.getName(), FunctionType::get(ctx, newParamTypes, newRetTypes));
    Block *newBody = newFunc.addEntryBlock();
    // Rewrite body into new func
    // - clone ops one by one
    // - replace original params by new params
    // - when we find memref.alloc that produces a return's parent,
    //   replace its result with new param and then delete it
    auto oldParams = oldBody.front().getArguments();
    auto newParams = newBody->getArguments();
    IRMapping irMap;
    {
      int i = 0;
      for(int retToParam : returnsToMakeParams) {
        Value retParent = kokkos::getParentMemref(ret->getOperands()[retToParam]);
        // In new function, replace retParent (result of alloc) with the corresponding new param
        irMap.map(retParent, newParams[i]);
        i++;
      }
    }
    // Map remaining params
    for(size_t i = 0; i < oldParams.size(); i++) {
      irMap.map(oldParams[i], newParams[returnsToMakeParams.size() + i]);
    }
    // Clone ops
    rewriter.setInsertionPointToStart(newBody);
    for(Operation& op : oldBody.front().getOperations()) {
      if(auto ret = dyn_cast<func::ReturnOp>(&op)) {
        SmallVector<Value> newReturns;
        for(auto retVal : ret->getOperands()) {
          newReturns.push_back(irMap.lookupOrDefault(retVal));
        }
        // and then remove the skipped return values
        for(int i = returnsToDelete.size() - 1; i >= 0; i--) {
          newReturns.erase(newReturns.begin() + returnsToDelete[i]);
        }
        rewriter.create<func::ReturnOp>(ret->getLoc(), newReturns);
      }
      else if(auto alloc = dyn_cast<memref::AllocOp>(&op)) {
        if(allocsToDelete.find(alloc) == allocsToDelete.end()) {
          // Don't delete this alloc
          rewriter.clone(op, irMap);
        }
        else {
          // Delete this alloc, and replace its result with a new param
          irMap.map(alloc.getResult(), newParams[allocsToDelete[alloc]]);
        }
      }
      else {
        rewriter.clone(op, irMap);
      }
    }
    //finally, delete the original function
    rewriter.eraseOp(oldFunc);
  }

  void runOnOperation() override {
    MLIRContext* ctx = &getContext();
    IRRewriter rewriter(ctx);
    ModuleOp m = getOperation();
    m.walk<WalkOrder::PostOrder>([&](func::FuncOp oldFunc) {
      rewriteFunction(rewriter, ctx, oldFunc);
    });
  }
};

std::unique_ptr<Pass> mlir::createMemrefResultsToParamsPass()
{
  return std::make_unique<MemrefResultsToParamsPass>();
}

